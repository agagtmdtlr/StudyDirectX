#include "Example.h"

#include <omp.h>

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image_write.h>

#include <algorithm> // std::clamp (C++17)

void Image::ReadFromFile(const char* filename)
{
    /*
    vcpkg install stb:x64-windows
    프로젝트 설정에서 _CRT_SECURE_NO_WARNINGS 추가 ('sprintf' in stb_image_write.h)
    #define STB_IMAGE_IMPLEMENTATION
    #include <stb_image.h>
    #define STB_IMAGE_WRITE_IMPLEMENTATION
    #include <stb_image_write.h>
    */

    unsigned char* img = stbi_load(filename, &width, &height, &channels, 0);


    if (width)
    {
        std::cout << width << " " << height << " " << channels << std::endl;
    }
    else
    {
        std::cout << "Error : reading " << filename << " failed." << std::endl;
    }

    // channels가 3(RGB) 또는 4(RGBA)인 경우만 가정
    // unsigned char(0에서 255)을 4채널 float(0.0f에서 1.0f)로 변화
    pixels.resize(width * height);
    for (int i = 0; i < width * height; i++)
    {
        pixels[i].v[0] = img[i * channels] / 255.0f;
        pixels[i].v[1] = img[i * channels + 1] / 255.0f;
        pixels[i].v[2] = img[i * channels + 2] / 255.0f;
        pixels[i].v[3] = 1.0f;
    }

    delete[] img;
}

void Image::WritePNG(const char* filename)
{
    // 32bit에서 8bit로 변환 후에 저장
    std::vector<unsigned char> img(width * height* channels, 0);
    for (int i = 0; i < width * height; i++)
    {
        img[i* channels] = uint8_t(pixels[i].v[0] * 255.0f); // v[0]이 0.0f 이상 1.0f 이하 가정
        img[i* channels + 1] = uint8_t(pixels[i].v[1] * 255.0f);
        img[i * channels + 2] = uint8_t(pixels[i].v[2] * 255.0f);
    }

    stbi_write_png(filename,width, height, channels, img.data(), width * channels);
}

Vec4& Image::GetPixel(int i, int j)
{
    // TODO: 여기에 return 문을 삽입합니다.
    i = std::clamp(i, 0, this->width -1);
    j = std::clamp(j, 0, this->height - 1);


    return pixels[j * this->width + i];
}

void Image::BoxBlur5()
{
    std::vector<Vec4> pixelsBuffer(this->pixels.size()); // 사본 복사
    
    
    /*
    Separable convolution
    한번에 2차원 Kernel 을 적용하는 대신에 1차원 Kernel을 두번 적용
    이해하기 쉽고 효율적이다.
    */

    // 가로 방향 (x 방향 )
#pragma omp parallel for
    for (int j = 0; j < this->height; j++)
    {
        for (int i = 0; i < this->width; i++)
        {
            // 주변 픽셀들의 색을 평균내어서 (i,j)에 있는 픽셀의 색을 변경
            // this->pixels로부터 읽어온 값들을 평균내어서 pixelsBuffer의 값들을 바꾸기

            Vec4 kernelResult = {0.0f,0.0f,0.0f,0.0f};
            for (int c = 0; c < 5; c++)
            {
                int ci = std::clamp(i - 2, 0, this->width - 1);
                kernelResult += pixels[j * this->width + ci];
                kernelResult /= 5.0f;
            }

            pixelsBuffer[j * width + i] = kernelResult;
        }
    }

    // Swap
    std::swap(this->pixels, pixelsBuffer);

    return;     
}

void Image::GaussianBlur5()
{
}

void Image::Bloom(const float& th, const int& numRepeat, const float& weight)
{
}
